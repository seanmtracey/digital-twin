<main>	

	<canvas id="creationCanvas"></canvas>
    
    <div id="nodes">

        <!-- The output is where our nodes are persisted -->

    </div>

    <div id="configurePanel" data-active="false">
        <h2>Configure Node</h2>
        <div id="closePanelBtn"></div>

        <form>
            <label>Topic</label>
            <input type="text" name="topic" placeholder="MQTT topic to subscribe and react to..." />

            <label>Rules</label>
            
            <div id="nodeRules">
                
                <ol id="storedRules">
                
                    <!--<li class="rule">
                        <div class="ruleDetails">
                            <input type="text" name="rule_name" placeholder="Rule Name"/>
                            <div class="ruleCondition">
                                <strong>IF</strong> <input type="text" class="userInput" name="property" placeholder="property" /> &#61;&#61;&#61; <input type="text" class="userInput" name="value" placeholder="value"/><br/>
                            </div>

                            <div class="ruleAction">
                                <strong>SET COLOR</strong> <input type="color" id="head" name="head" value="#f5f5f5" class="userInput">
                            </div>

                        </div>
                        <div class="deleteRuleButton"></div>
                    </li>-->
                
                </ol>
                
                <button id="newRule">Add new rule</button>
            </div>

        </form>

    </div>

    <ul id="toolBox">

        <li data-selected="true" data-toolname="square" id="squareCreationTool"></li>
        <li data-selected="false" data-toolname="ellipse" id="ellipseCreationTool"></li>
        <li data-selected="false" data-toolname="select" id="selectionTool"></li>
        <li data-selected="false" data-toolname="image" id="imageTool"></li>
        
    </ul>

    <div id="colorSelect">
        <input type="color" id="head" name="head" value="#f5f5f5">
        <p> <strong> #F5F5F5 </strong> </p>
    </div>

    <div id="backgroundImageOverlay" data-active="false">

        <div id="imageHolder">
            <img />
        </div>

        <div id="backgroundImageOverlayActions">
            <button data-action="cancel">Cancel</button>
            <button data-action="save">Save</button>
        </div>

    </div>

    <div id="twinDetails">
        <span>Twin name:</span> <h3 id="twinNameSetting" contenteditable="true">{{twinData.name}}</h3>
        <span>Twin Broker: </span> <h3 id="twinBrokerSetting" contenteditable="true">{{twinData.broker}}</h3>
        <a href="/view/{{twinData.UUID}}" target="_blank">View Twin</a>
    </div>

    <script src="/scripts/utilities.js"></script>
    <script src="/scripts/twin_nodes.js"></script>
    <script>

        (function(){

            'use strict';

            const configurationPanel = (function(){
                
                const configurationPanelElement = document.querySelector('#configurePanel');
                let currentNodeBeingConfigured = undefined;

                const backgroundImageOverlay = document.querySelector('#backgroundImageOverlay');
                const backgroundImageOverlayImageHolder = backgroundImageOverlay.querySelector('#imageHolder');
                const backgroundImageElement = backgroundImageOverlayImageHolder.querySelector('img');

                const rulesContainer = configurationPanelElement.querySelector('#nodeRules');
                const storedRules = rulesContainer.querySelector('#storedRules');
                const newRulesButton = configurationPanelElement.querySelector('#newRule');

                function createRule(name, conditionProperty = "", conditionValue = "", actionValue = ""){

                    const ruleFragment = document.createDocumentFragment();
                    
                    const newRule = document.createElement('li');
                    const ruleDetailsContainer = document.createElement('div');
                    const ruleConditionContainer = document.createElement('div');
                    const ruleActionContainer = document.createElement('div');
                    const deleteRuleButton = document.createElement('div');
                    const nameInput = document.createElement('input');

                    newRule.classList.add('rule');
                    ruleDetailsContainer.classList.add('ruleDetails');
                    ruleConditionContainer.classList.add('ruleCondition');
                    ruleActionContainer.classList.add('ruleCondition');
                    deleteRuleButton.classList.add('deleteRuleButton');

                    nameInput.setAttribute('type', 'text');
                    nameInput.setAttribute('name', 'rule_name');
                    nameInput.setAttribute('placeholder', 'Rule Name');

                    nameInput.value = name || "";
                    ruleConditionContainer.innerHTML = `<strong>IF</strong> <input type="text" class="userInput" name="property" placeholder="property" value="${conditionProperty}" /> &#61;&#61;&#61; <input type="text" class="userInput" name="value" placeholder="value" value="${conditionValue}"/><br/>`;
                    ruleActionContainer.innerHTML = `<strong>SET COLOR</strong> <input type="color" id="head" name="head" value="${actionValue}" class="userInput">`

                    deleteRuleButton.addEventListener('click', function(){
                        
                        storedRules.removeChild(this.parentNode);

                    }, false);

                    ruleDetailsContainer.appendChild(nameInput);
                    ruleDetailsContainer.appendChild(ruleConditionContainer);
                    ruleDetailsContainer.appendChild(ruleActionContainer);

                    newRule.appendChild(ruleDetailsContainer);
                    newRule.appendChild(deleteRuleButton);

                    ruleFragment.appendChild(newRule);

                    return ruleFragment;

                }

                newRulesButton.addEventListener('click', function(e){
                    e.preventDefault();
                    e.stopImmediatePropagation();

                    const newRule = createRule();
                    
                    storedRules.appendChild(newRule);

                }, false);

                function showConfigurationPanel(node){
                    console.log("ShowPanel");

                    currentNodeBeingConfigured = node;
                    storedRules.innerHTML = "";

                    configurationPanelElement.querySelector('input[name="topic"]').value = currentNodeBeingConfigured.dataset.topic;
                    
                    if(currentNodeBeingConfigured.dataset.rules){

                        const rules = JSON.parse(currentNodeBeingConfigured.dataset.rules);

                        rules.forEach(rule => {

                            const existingRule = createRule(rule.name, rule.property, rule.value, rule.action);
                            storedRules.appendChild(existingRule);

                        });

                    }

                    configurationPanelElement.dataset.active = "true";                    

                }

                function hideConfigurationPanel(saveChanges = true){

                    console.log('save changes?', saveChanges);

                    if(true /*saveChanges*/){

                        currentNodeBeingConfigured.dataset.topic = configurationPanelElement.querySelector('input[name="topic"]').value;
                        const rules = Array.from(storedRules.querySelectorAll('.rule')).map(storedRule => {
                            console.log(storedRule);

                            const property = storedRule.querySelector('input[name="property"]').value;
                            const value = storedRule.querySelector('input[name="value"]').value;
                            const action = storedRule.querySelector('input[type="color"]').value;

                            return {
                                name : storedRule.querySelector('input[name="rule_name"]').value,
                                property : property/*.replace(/\./g, ':')*/,
                                value : value,
                                action : action
                            };

                        });

                        currentNodeBeingConfigured.dataset.rules = JSON.stringify(rules);

                    }
                    
                    currentNodeBeingConfigured = undefined;
                    configurationPanelElement.dataset.active = "false";

                    Array.from(storedRules.querySelectorAll('.rule')).forEach(storedRule => {
                        storedRule.parentNode.removeChild(storedRule);
                    });
                    
                    Array.from(nodesHolder.querySelectorAll('.node')).forEach(node => {
                        node.dataset.selected = "false";
                    });

                }

                function checkIfConfigurationPanelIsShowing(){
                    return configurationPanelElement.dataset.active === "true";
                }

                configurationPanelElement.querySelector('#closePanelBtn').addEventListener('click', e => {
                    hideConfigurationPanel(false);
                }, false);

                return {
                    show : showConfigurationPanel,
                    hide : hideConfigurationPanel,
                    isVisible : checkIfConfigurationPanelIsShowing
                };

            }());

            function bindCreationHandlersToNode(node, backgroundImage = false){
                
                function finishMoveOfNodeAndSetPosition(){
                    
                    MOVING = false;
                    nodeToMove.dataset.top = nodeToMove.style.top.replace('px', '');
                    nodeToMove.dataset.left = nodeToMove.style.left.replace('px', '');

                    originalMousePosition = undefined;
                    nodeToMove = undefined;

                    document.body.dataset.movingnode = "false";
                
                }

                function handleDownEvent(e){

                    e.preventDefault();
                    e.stopImmediatePropagation();

                    MOVING = true;
                    nodeToMove = e.target;
                    document.body.dataset.movingnode = true;

                    originalMousePosition = {
                        x : e.clientX,
                        y : e.clientY
                    };

                }

                function handleUpEvent(e){

                    e.stopPropagation();
                    e.stopImmediatePropagation();

                    console.log('NODE CLICK');

                    if(originalMousePosition){

                        if(e.clientX === originalMousePosition.x && e.clientY === originalMousePosition.y){
                            MOVING = false;
                        }

                    }

                    if(CREATING){
                        endCreationHandler(e);
                    } else if(!MOVING){
                        configurationPanel.show(e.target);
                        
                        Array.from(nodesHolder.querySelectorAll('.node')).forEach(node => {
                            node.dataset.selected = "false";
                        });

                        e.target.dataset.selected = "true";

                    } else if(MOVING){
                        finishMoveOfNodeAndSetPosition();
                    }

                }

                node.addEventListener('mousedown', handleDownEvent, false);
                node.addEventListener('mousemove', inProgressCreationHandler, false);
                node.addEventListener('mouseup', handleUpEvent, false);
                
                node.addEventListener("touchstart", function(e){ e.clientX = e.touches[0].clientX; e.clientY = e.touches[0].clientY; handleDownEvent(e); }, false);
                node.addEventListener("touchmove", function(e){ e.clientX = e.touches[0].clientX; e.clientY = e.touches[0].clientY; inProgressCreationHandler(e); }, false);
                node.addEventListener("touchend", function(e){ e.clientX = e.changedTouches[0].clientX; e.clientY = e.changedTouches[0].clientY; handleUpEvent(e); }, false);

            }

            function startCreationHandler(e){
                console.log('MOUSEDOWN');

                if(selectedTool !== "select"){

                    CREATING = true;
                    startCoords = {
                        x : e.clientX,
                        y : e.clientY
                    };

                }
                
            }

            function inProgressCreationHandler(e){
                
                if(CREATING){

                    const selectionWidth = e.clientX - startCoords.x;
                    const selectionHeight = e.clientY - startCoords.y;

                    if(selectedTool === "square"){

                        creationCtx.clearRect(0,0, creationCanvas.width, creationCanvas.height);
                        creationCtx.beginPath();
                        creationCtx.strokeRect(startCoords.x * window.devicePixelRatio, startCoords.y * window.devicePixelRatio, selectionWidth * window.devicePixelRatio, selectionHeight * window.devicePixelRatio);
                        creationCtx.stroke();
                        creationCtx.closePath();

                    } else if(selectedTool === "ellipse"){
                        
                        creationCtx.clearRect(0,0, creationCanvas.width, creationCanvas.height);

                        const adjustedX = e.clientX * window.devicePixelRatio;
                        const adjustedY = e.clientY * window.devicePixelRatio

                        const adjustedStartX = startCoords.x * window.devicePixelRatio;
                        const adjustedStartY = startCoords.y * window.devicePixelRatio;

                        const height = (adjustedY - adjustedStartY) ;
                        const width = (adjustedX - adjustedStartX) ;
                        const centerX = ( ( adjustedX - ( (adjustedX - adjustedStartX) / 2 ) ) ) - width / 2;
                        const centerY = ( ( adjustedY - ( (adjustedY - adjustedStartY) / 2 ) ) ) - height / 2;

                        // Borrowed from https://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
                        const kappa = 0.5522848;
                        const ox = (width / 2) * kappa; // control point offset horizontal
                        const oy = (height / 2) * kappa; // control point offset vertical
                        const xe = centerX + width; // x-end
                        const ye = centerY + height; // y-end
                        const xm = centerX + width / 2; // x-middle
                        const ym = centerY + height / 2; // y-middle

                        creationCtx.beginPath();
                        creationCtx.moveTo(centerX, ym);
                        creationCtx.bezierCurveTo(centerX, ym - oy, xm - ox, centerY, xm, centerY);
                        creationCtx.bezierCurveTo(xm + ox, centerY, xe, ym - oy, xe, ym);
                        creationCtx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                        creationCtx.bezierCurveTo(xm - ox, ye, centerX, ym + oy, centerX, ym);
                        creationCtx.stroke();
                        creationCtx.closePath();

                    }

                } else if(MOVING){
                    console.log('MOVING');

                    const offsetX = originalMousePosition.x - e.clientX;
                    const offsetY = originalMousePosition.y - e.clientY;

                    nodeToMove.style.left = `${nodeToMove.dataset.left - offsetX}px`;
                    nodeToMove.style.top = `${nodeToMove.dataset.top - offsetY}px`;

                }

            }

            function endCreationHandler(e){

                console.log('MOUSEUP');
                
                if(CREATING){

                    creationCtx.clearRect(0, 0, creationCanvas.width, creationCanvas.height);
                    
                    const elementWidth = e.clientX - startCoords.x;
                    const elementHeight = e.clientY - startCoords.y;

                    if(elementWidth === 0 || elementHeight === 0){
                        CREATING = false;
                        startCoords = undefined;
                        return;
                    }

                    const positionX = e.clientX < startCoords.x ? e.clientX : startCoords.x;
                    const positionY = e.clientY < startCoords.y ? e.clientY : startCoords.y;

                    const node = twinNodes.create(positionX, positionY, elementWidth, elementHeight, selectedTool, utilities.uuid());

                    bindCreationHandlersToNode(node);

                    nodesHolder.appendChild(node);
                
                } else if(MOVING){
                    
                    finishMoveOfNodeAndSetPosition();

                }

                CREATING = false;

            }

            function updateTwinSettings(){

                const twinName = twinNameSetting.textContent;
                const twinBroker = twinBrokerSetting.textContent;

                fetch(`${window.location.origin}/twins/update/${twinUUID}`, {
                        method : 'POST',
                        headers : {
                            'Content-Type' : 'application/json'
                        },
                        credentials : 'same-origin',
                        body: JSON.stringify( { data : { name : twinName, broker: twinBroker } })
                    })
                    .then(res => {
                        if(res.ok){
                            return res.json();
                        } else {
                            throw res;
                        }
                    })
                    .then(result => {
                        console.log('Updated twin settings:', result);
                    })
                    .catch(err => {
                        console.log('Could not update Twin settings. Err:', err);
                    })

                console.log(twinName, twinBroker);

            }

            function saveBackgroundImage(src, type){
                
                fetch(`${window.location.origin}/twins/image/set/${twinUUID}`, {
                        method : "POST",
                        headers : {
                            "Content-Type" : "application/json"
                        },
                        credentials : 'same-origin',
                        body : JSON.stringify( { data : { backgroundImage : src, type : type.replace('image/', '') } } )
                    })
                    .then(res => {
                        if(!res.ok){
                            throw res;
                        } else {
                            return res.json()
                        }
                    })
                    .then(data => {
                        console.log(data);
                    })
                    .catch(err => {

                        console.log(`Error saving Digital Twin updates:`, err);

                    })
                ;

            }

            function setBackgroundImage(src, position, size){

                console.log(src);

                const backgroundImage = new Image();

                backgroundImage.classList.add('backgroundImage');
                
                backgroundImage.addEventListener('load', function(){
                    console.log('Image Loaded');

                    if(position){
                        backgroundImage.dataset.left = position.x;
                        backgroundImage.dataset.top = position.y;
                    } else {
                        backgroundImage.dataset.left = (window.innerWidth / 2) - (backgroundImage.width / 2);
                        backgroundImage.dataset.top = (window.innerHeight / 2) - (backgroundImage.height / 2);
                    }

                    bindCreationHandlersToNode(backgroundImage, true);
                    backgroundImage.style.left = `${backgroundImage.dataset.left}px`;
                    backgroundImage.style.top = `${backgroundImage.dataset.top}px`;

                    nodesHolder.insertBefore(backgroundImage, document.querySelector('.node'));

                }, false);

                backgroundImage.src = src;

            }

            const twinUUID = "{{twinData.UUID}}";
            const nodesHolder = document.querySelector('#nodes');
            const toolBox = document.querySelector('#toolBox');
            const colorSelectorHolder = document.querySelector('#colorSelect');
            const colorSelector = colorSelectorHolder.querySelector('input[type="color"]');
            const colorSelectorOutput = colorSelectorHolder.querySelector('p');
            const creationCanvas = document.querySelector('canvas#creationCanvas');
            const creationCtx = creationCanvas.getContext('2d');
            const twinNameSetting = document.querySelector('#twinNameSetting');
            const twinBrokerSetting = document.querySelector('#twinBrokerSetting');

            creationCanvas.width = window.innerWidth * window.devicePixelRatio;
            creationCanvas.height = window.innerHeight * window.devicePixelRatio;

            creationCtx.strokeStyle = "#333333";
            creationCtx.lineWidth = 4;

            let CREATING = false;
            let startCoords = undefined;
            let selectedTool = toolBox.querySelector('li[data-selected="true"]').dataset.toolname;
            
            let MOVING = false;
            let originalMousePosition;
            let nodeToMove;

            const validImageFileTypes = ['image/jpeg', 'image/png'];

            creationCanvas.addEventListener('mousedown', startCreationHandler, false);
            creationCanvas.addEventListener("touchstart", function(e){ e.clientX = e.touches[0].clientX; e.clientY = e.touches[0].clientY; startCreationHandler(e); }, false);

            creationCanvas.addEventListener('mousemove', inProgressCreationHandler, false);
            creationCanvas.addEventListener("touchmove", function(e){ e.clientX = e.touches[0].clientX; e.clientY = e.touches[0].clientY; inProgressCreationHandler(e); }, false);
            toolBox.addEventListener('mousemove', inProgressCreationHandler, false);
            
            creationCanvas.addEventListener('mouseup', endCreationHandler, false);
            creationCanvas.addEventListener("touchend", function(e){ e.clientX = e.changedTouches[0].clientX; e.clientY = e.changedTouches[0].clientY; endCreationHandler(e); }, false);
            toolBox.addEventListener('mouseup', endCreationHandler, false);

            function handleDragEnter(e){
                e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
                console.log('dragenter event triggered');
            }

            function handleDragLeave(e){
                e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
                console.log('dragleave event triggered');
            }

            function handleDragOver(e){
                e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
                console.log('dragover event triggered');
            }

            function handleDrop(e){
                e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
                console.log('drop event triggered', e);
                let dt = e.dataTransfer
                let file = dt.files[0];

                console.log(dt, file);

                if(validImageFileTypes.indexOf(file.type) > -1){
                    console.log('Valid image file');

                    const reader = new FileReader();
                    reader.readAsDataURL(file)
                    //reader.onloadend = function() {}
                    reader.addEventListener('loadend', function(){
                        console.log(reader.result);
                        setBackgroundImage(reader.result);
                        saveBackgroundImage(reader.result, file.type);
                    }, false);
                }

            }

            /*document.body.addEventListener('dragenter', handleDragEnter, false);
            document.body.addEventListener('dragleave', handleDragLeave, false);
            document.body.addEventListener('dragover', handleDragOver, false);
            document.body.addEventListener('drop', handleDrop, false);*/

            Array.from(toolBox.querySelectorAll('li')).map(tool => {

                tool.addEventListener('click', function(){

                    Array.from(toolBox.querySelectorAll('li')).forEach(tool => {

                        tool.dataset.selected = "false";

                    }, false);

                    this.dataset.selected = "true";
                    selectedTool = this.dataset.toolname;

                    if(selectedTool === 'image'){

                    } else {

                    }

                }, false);

            }, false);

            // Reconstruct pre-existing nodes
            const existingNodes = JSON.parse(`{{{ twinData.nodes }}}`);

            existingNodes.forEach(savedNode => {

                // x, y, width, height, type = selectedTool
                const recreatedNode = twinNodes.create(savedNode.left, savedNode.top, savedNode.width, savedNode.height, savedNode.type, savedNode.name, savedNode.topic, savedNode.rules);
                
                bindCreationHandlersToNode(recreatedNode);

                nodesHolder.appendChild(recreatedNode);

            });

            const nodeMutationObsererOptions = {
                childList: true,
                attributes: true,
                subtree: true
            };

            const NodeMutationObserver = new MutationObserver(function(mutations) {
 
                console.log(mutations);

                if(!MOVING){
                    twinNodes.update( Array.from( nodesHolder.querySelectorAll('div.node') ), twinUUID );
                }
 
            });

            NodeMutationObserver.observe(nodesHolder, nodeMutationObsererOptions);       

            colorSelector.addEventListener('change', function(e){

                console.log("change", this.value);
                creationCanvas.style.backgroundColor = this.value;
                colorSelectorOutput.textContent = this.value.toUpperCase();

            }, false);

            twinNameSetting.addEventListener('keydown', function(e){ if( e.keyCode === 13 ){ e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation(); this.blur(); } });
            twinBrokerSetting.addEventListener('keydown', function(e){ if( e.keyCode === 13 ){ e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation(); this.blur(); } });

            twinNameSetting.addEventListener('blur', updateTwinSettings, false);
            twinBrokerSetting.addEventListener('blur', updateTwinSettings, false);

            window.addEventListener('keydown', (e) => {
                console.log(e);
                // If the backspace key is pressed, and a node is selected, but the none of the input
                // fields in the configuration panel are being edited, delete the selected node.
                
                const selectedNode = nodesHolder.querySelector('.node[data-selected="true"]');

                if(e.keyCode === 8 && e.ctrlKey === true && selectedNode !== null){
                    selectedNode.parentNode.removeChild(selectedNode);
                    configurationPanel.hide();
                }
                
            });

            window.addEventListener('resize', (e) => {
                creationCanvas.width = window.innerWidth * window.devicePixelRatio;
                creationCanvas.height = window.innerHeight * window.devicePixelRatio;
            }, false);

        }());

    </script>

</main>