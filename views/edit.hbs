<main>

	<canvas id="creationCanvas"></canvas>

    <div id="nodes">

        <!-- The output are where nodes are persisted -->

    </div>

    <div id="configurePanel" data-active="true">
        <h2>Configure Node</h2>
        <div id="closePanelBtn"></div>

        <form>
            <label>Topic</label>
            <input type="text" name="topic" placeholder="MQTT topic to subscribe and respond to..." />

            <label>Rules</label>
            
            <div id="nodeRules">
                
                <ol id="storedRules">
                
                    <li class="rule">
                        <div class="ruleDetails">
                            <input type="text" name="rule_name" placeholder="Rule Name"/>
                            <div class="ruleCondition">
                                <strong>IF</strong> <input type="text" class="userInput" name="property" placeholder="property" /> &#61;&#61;&#61; <input type="text" class="userInput" name="value" placeholder="value"/><br/>
                            </div>

                            <div class="ruleAction">
                                <!--<select id="actionToUndertake">
                                    <option value="setColor">Set Color</option>
                                </select>-->
                                <strong>SET COLOR</strong> <input type="color" id="head" name="head" value="#f5f5f5" class="userInput">
                            </div>

                        </div>
                        <div class="deleteRuleButton"></div>
                    </li>
                
                </ol>
                
                <button id="newRule">Add new rule</button>
            </div>

        </form>

    </div>

    <ul id="toolBox">

        <li data-selected="true" data-toolname="square" id="squareCreationTool"></li>
        <li data-selected="false" data-toolname="ellipse" id="ellipseCreationTool"></li>
        <li data-selected="false" data-toolname="select" id="selectionTool"></li>

    </ul>

    <div id="colorSelect">
        <input type="color" id="head" name="head" value="#f5f5f5">
        <p> <strong> #F5F5F5 </strong> </p>
    </div>

    <div id="twinDetails">
        <h3>{{twinData.name}}</h3>
        <p>Created by {{twinData.owner}}</p>
    </div>

    <script src="/scripts/utilities.js"></script>
    <script src="/scripts/twin_nodes.js"></script>
    <script>

        (function(){

            'use strict';

            const configurationPanel = (function(){
                
                const configurationPanelElement = document.querySelector('#configurePanel');
                let currentNodeBeingConfigured = undefined;

                const rulesContainer = configurationPanelElement.querySelector('#nodeRules');
                const storedRules = rulesContainer.querySelector('#storedRules');
                const newRulesButton = configurationPanelElement.querySelector('#newRule');

                function createRule(name, content){

                    const ruleFragment = document.createDocumentFragment();
                    
                    const newRule = document.createElement('li');
                    const ruleDetailsContainer = document.createElement('div');
                    const deleteRuleButton = document.createElement('div');
                    const nameInput = document.createElement('input');

                    newRule.classList.add('rule');
                    ruleDetailsContainer.classList.add('ruleDetails');
                    deleteRuleButton.classList.add('deleteRuleButton');

                    nameInput.setAttribute('type', 'text');
                    nameInput.setAttribute('name', 'rule_name');
                    nameInput.setAttribute('placeholder', 'Rule Name');

                    nameInput.value = name || "";

                    deleteRuleButton.addEventListener('click', function(){
                        
                        storedRules.removeChild(this.parentNode);

                    }, false);

                    ruleDetailsContainer.appendChild(nameInput);

                    newRule.appendChild(ruleDetailsContainer);
                    newRule.appendChild(deleteRuleButton);

                    ruleFragment.appendChild(newRule);


                    return ruleFragment;

                }

                newRulesButton.addEventListener('click', function(e){
                    e.preventDefault();
                    e.stopImmediatePropagation();

                    const newRule = createRule();
                    
                    storedRules.appendChild(newRule);

                }, false);

                function showConfigurationPanel(node){
                    console.log("ShowPanel");

                    currentNodeBeingConfigured = node;
                    
                    configurationPanelElement.querySelector('input[name="topic"]').value = currentNodeBeingConfigured.dataset.topic;

                    configurationPanelElement.dataset.active = "true";                    

                }

                function hideConfigurationPanel(saveChanges = true){

                    console.log('save changes?', saveChanges);

                    currentNodeBeingConfigured.dataset.topic = configurationPanelElement.querySelector('input[name="topic"]').value;
                    
                    currentNodeBeingConfigured = undefined;
                    configurationPanelElement.dataset.active = "false";

                    Array.from(storedRules.querySelectorAll('.rule')).forEach(storedRule => {
                        storedRule.parentNode.removeChild(storedRule);
                    });
                    
                    Array.from(nodesHolder.querySelectorAll('.node')).forEach(node => {
                        node.dataset.selected = "false";
                    });

                }

                function checkIfConfigurationPanelIsShowing(){
                    return configurationPanelElement.dataset.active === "true";
                }

                configurationPanelElement.querySelector('#closePanelBtn').addEventListener('click', e => {
                    hideConfigurationPanel(false);
                }, false);

                return {
                    show : showConfigurationPanel,
                    hide : hideConfigurationPanel,
                    isVisible : checkIfConfigurationPanelIsShowing
                };

            }());

            function bindCreationHandlersToNode(node){
                
                node.addEventListener('mouseup', function(e){
                    e.stopPropagation();
                    e.stopImmediatePropagation();

                    console.log('NODE CLICK');

                    if(CREATING){
                        endCreationHandler(e);
                    } else {
                        configurationPanel.show(this);
                        
                        Array.from(nodesHolder.querySelectorAll('.node')).forEach(node => {
                            node.dataset.selected = "false";
                        });

                        this.dataset.selected = "true";

                    }

                }, false);

                node.addEventListener('mousemove', inProgressCreationHandler, false);
                node.addEventListener('mouseup', endCreationHandler, false);
                
            }

            function startCreationHandler(e){
                console.log('MOUSEDOWN');

                if(selectedTool !== "select"){

                    CREATING = true;
                    startCoords = {
                        x : e.clientX,
                        y : e.clientY
                    };

                }
                

            }

            function inProgressCreationHandler(e){
                
                if(CREATING){

                    const selectionWidth = e.clientX - startCoords.x;
                    const selectionHeight = e.clientY - startCoords.y;

                    creationCtx.clearRect(0,0, creationCanvas.width, creationCanvas.height);
                    creationCtx.strokeRect(startCoords.x, startCoords.y, selectionWidth, selectionHeight);
                    creationCtx.stroke();

                }

            }

            function endCreationHandler(e){

                console.log('MOUSEUP');
                
                if(CREATING){

                    creationCtx.clearRect(0, 0, creationCanvas.width, creationCanvas.height);
                    
                    const elementWidth = e.clientX - startCoords.x;
                    const elementHeight = e.clientY - startCoords.y

                    const positionX = e.clientX < startCoords.x ? e.clientX : startCoords.x;
                    const positionY = e.clientY < startCoords.y ? e.clientY : startCoords.y;

                    const node = twinNodes.create(positionX, positionY, elementWidth, elementHeight, selectedTool, utilities.uuid());

                    bindCreationHandlersToNode(node);

                    nodesHolder.appendChild(node);
                
                }

                CREATING = false;
                startCoords = undefined;

            }

            const twinUUID = "{{twinData.UUID}}";
            const nodesHolder = document.querySelector('#nodes');
            const toolBox = document.querySelector('#toolBox');
            const colorSelectorHolder = document.querySelector('#colorSelect');
            const colorSelector = colorSelectorHolder.querySelector('input[type="color"]');
            const colorSelectorOutput = colorSelectorHolder.querySelector('p');
            const creationCanvas = document.querySelector('canvas#creationCanvas');
            const creationCtx = creationCanvas.getContext('2d');

            creationCanvas.width = window.innerWidth;
            creationCanvas.height = window.innerHeight;

            creationCtx.strokeStyle = "1px #333333";

            let CREATING = false;
            let startCoords = undefined;
            let selectedTool = toolBox.querySelector('li[data-selected="true"]').dataset.toolname;

            creationCanvas.addEventListener('mousedown', startCreationHandler, false);
            
            creationCanvas.addEventListener('mousemove', inProgressCreationHandler, false);
            toolBox.addEventListener('mousemove', inProgressCreationHandler, false);
            
            creationCanvas.addEventListener('mouseup', endCreationHandler, false);
            toolBox.addEventListener('mouseup', endCreationHandler, false);

            Array.from(toolBox.querySelectorAll('li')).map(tool => {

                tool.addEventListener('click', function(){

                    Array.from(toolBox.querySelectorAll('li')).forEach(tool => {

                        tool.dataset.selected = "false";

                    }, false);

                    this.dataset.selected = "true";
                    selectedTool = this.dataset.toolname;

                }, false);

            }, false);

            // Reconstruct pre-existing nodes
            const existingNodes = JSON.parse(`{{{ twinData.nodes }}}`);

            existingNodes.forEach(savedNode => {

                // x, y, width, height, type = selectedTool
                const recreatedNode = twinNodes.create(savedNode.left, savedNode.top, savedNode.width, savedNode.height, savedNode.type, savedNode.name, savedNode.topic, savedNode.rules);
                
                bindCreationHandlersToNode(recreatedNode);

                nodesHolder.appendChild(recreatedNode);

            });

            const nodeMutationObsererOptions = {
                childList: true,
                attributes: true,
                subtree: true
            };

            const NodeMutationObserver = new MutationObserver(function(mutations) {
 
                console.log(mutations);
                twinNodes.update( Array.from( nodesHolder.querySelectorAll('div.node') ), twinUUID );
 
            });

            NodeMutationObserver.observe(nodesHolder, nodeMutationObsererOptions);       

            colorSelector.addEventListener('change', function(e){

                console.log("change", this.value);
                creationCanvas.style.backgroundColor = this.value;
                colorSelectorOutput.textContent = this.value.toUpperCase();

            }, false);

            window.addEventListener('resize', (e) => {
                creationCanvas.width = window.innerWidth;
                creationCanvas.height = window.innerHeight;
            }, false);

        }());

    </script>

</main>