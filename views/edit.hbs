<main>

	<canvas id="creationCanvas"></canvas>

    <div id="nodes">

        <!-- The output is where our nodes are persisted -->

    </div>

    <div id="configurePanel" data-active="false">
        <h2>Configure Node</h2>
        <div id="closePanelBtn"></div>

        <form>
            <label>Topic</label>
            <input type="text" name="topic" placeholder="MQTT topic to subscribe and react to..." />

            <label>Rules</label>
            
            <div id="nodeRules">
                
                <ol id="storedRules">
                
                    <!--<li class="rule">
                        <div class="ruleDetails">
                            <input type="text" name="rule_name" placeholder="Rule Name"/>
                            <div class="ruleCondition">
                                <strong>IF</strong> <input type="text" class="userInput" name="property" placeholder="property" /> &#61;&#61;&#61; <input type="text" class="userInput" name="value" placeholder="value"/><br/>
                            </div>

                            <div class="ruleAction">
                                <strong>SET COLOR</strong> <input type="color" id="head" name="head" value="#f5f5f5" class="userInput">
                            </div>

                        </div>
                        <div class="deleteRuleButton"></div>
                    </li>-->
                
                </ol>
                
                <button id="newRule">Add new rule</button>
            </div>

        </form>

    </div>

    <ul id="toolBox">

        <li data-selected="true" data-toolname="square" id="squareCreationTool"></li>
        <li data-selected="false" data-toolname="ellipse" id="ellipseCreationTool"></li>
        <li data-selected="false" data-toolname="select" id="selectionTool"></li>

    </ul>

    <div id="colorSelect">
        <input type="color" id="head" name="head" value="#f5f5f5">
        <p> <strong> #F5F5F5 </strong> </p>
    </div>

    <div id="twinDetails">
        <h3>{{twinData.name}}</h3>
        <p>{{twinData.broker}}</p>
        <a href="/view/{{twinData.UUID}}" target="_blank">View Twin</a>
    </div>

    <script src="/scripts/utilities.js"></script>
    <script src="/scripts/twin_nodes.js"></script>
    <script>

        (function(){

            'use strict';

            const configurationPanel = (function(){
                
                const configurationPanelElement = document.querySelector('#configurePanel');
                let currentNodeBeingConfigured = undefined;

                const rulesContainer = configurationPanelElement.querySelector('#nodeRules');
                const storedRules = rulesContainer.querySelector('#storedRules');
                const newRulesButton = configurationPanelElement.querySelector('#newRule');

                function createRule(name, conditionProperty = "", conditionValue = "", actionValue = ""){

                    const ruleFragment = document.createDocumentFragment();
                    
                    const newRule = document.createElement('li');
                    const ruleDetailsContainer = document.createElement('div');
                    const ruleConditionContainer = document.createElement('div');
                    const ruleActionContainer = document.createElement('div');
                    const deleteRuleButton = document.createElement('div');
                    const nameInput = document.createElement('input');

                    newRule.classList.add('rule');
                    ruleDetailsContainer.classList.add('ruleDetails');
                    ruleConditionContainer.classList.add('ruleCondition');
                    ruleActionContainer.classList.add('ruleCondition');
                    deleteRuleButton.classList.add('deleteRuleButton');

                    nameInput.setAttribute('type', 'text');
                    nameInput.setAttribute('name', 'rule_name');
                    nameInput.setAttribute('placeholder', 'Rule Name');

                    nameInput.value = name || "";
                    ruleConditionContainer.innerHTML = `<strong>IF</strong> <input type="text" class="userInput" name="property" placeholder="property" value="${conditionProperty}" /> &#61;&#61;&#61; <input type="text" class="userInput" name="value" placeholder="value" value="${conditionValue}"/><br/>`;
                    ruleActionContainer.innerHTML = `<strong>SET COLOR</strong> <input type="color" id="head" name="head" value="${actionValue}" class="userInput">`

                    deleteRuleButton.addEventListener('click', function(){
                        
                        storedRules.removeChild(this.parentNode);

                    }, false);

                    ruleDetailsContainer.appendChild(nameInput);
                    ruleDetailsContainer.appendChild(ruleConditionContainer);
                    ruleDetailsContainer.appendChild(ruleActionContainer);

                    newRule.appendChild(ruleDetailsContainer);
                    newRule.appendChild(deleteRuleButton);

                    ruleFragment.appendChild(newRule);

                    return ruleFragment;

                }

                newRulesButton.addEventListener('click', function(e){
                    e.preventDefault();
                    e.stopImmediatePropagation();

                    const newRule = createRule();
                    
                    storedRules.appendChild(newRule);

                }, false);

                function showConfigurationPanel(node){
                    console.log("ShowPanel");

                    currentNodeBeingConfigured = node;
                    storedRules.innerHTML = "";

                    configurationPanelElement.querySelector('input[name="topic"]').value = currentNodeBeingConfigured.dataset.topic;
                    
                    if(currentNodeBeingConfigured.dataset.rules){

                        const rules = JSON.parse(currentNodeBeingConfigured.dataset.rules);

                        rules.forEach(rule => {

                            const existingRule = createRule(rule.name, rule.property, rule.value, rule.action);
                            storedRules.appendChild(existingRule);

                        });

                    }

                    configurationPanelElement.dataset.active = "true";                    

                }

                function hideConfigurationPanel(saveChanges = true){

                    console.log('save changes?', saveChanges);

                    if(true /*saveChanges*/){

                        currentNodeBeingConfigured.dataset.topic = configurationPanelElement.querySelector('input[name="topic"]').value;
                        const rules = Array.from(storedRules.querySelectorAll('.rule')).map(storedRule => {
                            console.log(storedRule);

                            const property = storedRule.querySelector('input[name="property"]').value;
                            const value = storedRule.querySelector('input[name="value"]').value;
                            const action = storedRule.querySelector('input[type="color"]').value;

                            return {
                                name : storedRule.querySelector('input[name="rule_name"]').value,
                                property : property/*.replace(/\./g, ':')*/,
                                value : value,
                                action : action
                            };

                        });

                        currentNodeBeingConfigured.dataset.rules = JSON.stringify(rules);

                    }
                    
                    currentNodeBeingConfigured = undefined;
                    configurationPanelElement.dataset.active = "false";

                    Array.from(storedRules.querySelectorAll('.rule')).forEach(storedRule => {
                        storedRule.parentNode.removeChild(storedRule);
                    });
                    
                    Array.from(nodesHolder.querySelectorAll('.node')).forEach(node => {
                        node.dataset.selected = "false";
                    });

                }

                function checkIfConfigurationPanelIsShowing(){
                    return configurationPanelElement.dataset.active === "true";
                }

                configurationPanelElement.querySelector('#closePanelBtn').addEventListener('click', e => {
                    hideConfigurationPanel(false);
                }, false);

                return {
                    show : showConfigurationPanel,
                    hide : hideConfigurationPanel,
                    isVisible : checkIfConfigurationPanelIsShowing
                };

            }());

            function bindCreationHandlersToNode(node){
                
                function finishMoveOfNodeAndSetPosition(){
                    
                    MOVING = false;
                    nodeToMove.dataset.top = nodeToMove.style.top.replace('px', '');
                    nodeToMove.dataset.left = nodeToMove.style.left.replace('px', '');

                    originalMousePosition = undefined;
                    nodeToMove = undefined;

                    document.body.dataset.movingnode = "false";
                
                }

                node.addEventListener('mousedown', function(e){
                    e.preventDefault();
                    e.stopImmediatePropagation();

                    MOVING = true;
                    nodeToMove = this;
                    document.body.dataset.movingnode = true;

                    originalMousePosition = {
                        x : e.clientX,
                        y : e.clientY
                    };

                }, false);

                node.addEventListener('mouseup', function(e){
                    e.stopPropagation();
                    e.stopImmediatePropagation();

                    console.log('NODE CLICK');

                    if(originalMousePosition){

                        if(e.clientX === originalMousePosition.x && e.clientY === originalMousePosition.y){
                            MOVING = false;
                        }

                    }

                    if(CREATING){
                        endCreationHandler(e);
                    } else if(!MOVING){
                        configurationPanel.show(this);
                        
                        Array.from(nodesHolder.querySelectorAll('.node')).forEach(node => {
                            node.dataset.selected = "false";
                        });

                        this.dataset.selected = "true";

                    } else if(MOVING){
                        finishMoveOfNodeAndSetPosition();
                    }

                }, false);

                node.addEventListener('mousemove', inProgressCreationHandler, false);
                node.addEventListener('mouseup', endCreationHandler, false);
                
            }

            function startCreationHandler(e){
                console.log('MOUSEDOWN');

                if(selectedTool !== "select"){

                    CREATING = true;
                    startCoords = {
                        x : e.clientX,
                        y : e.clientY
                    };

                }
                
            }

            function inProgressCreationHandler(e){
                
                if(CREATING){

                    const selectionWidth = e.clientX - startCoords.x;
                    const selectionHeight = e.clientY - startCoords.y;

                    if(selectedTool === "square"){

                        creationCtx.clearRect(0,0, creationCanvas.width, creationCanvas.height);
                        creationCtx.strokeRect(startCoords.x * window.devicePixelRatio, startCoords.y * window.devicePixelRatio, selectionWidth * window.devicePixelRatio, selectionHeight * window.devicePixelRatio);
                        creationCtx.stroke();

                    } else if(selectedTool === "ellipse"){
                        
                        creationCtx.clearRect(0,0, creationCanvas.width, creationCanvas.height);

                        const height = (e.clientY - startCoords.y) * 2;
                        const width = (e.clientX - startCoords.x) * 2;
                        const centerX = ( ( e.clientX - ( (e.clientX - startCoords.x) / 2 ) ) * 2 ) - width / 2;
                        const centerY = ( ( e.clientY - ( (e.clientY - startCoords.y) / 2 ) ) * 2 ) - height / 2;

                        // Borrowed from https://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
                        const kappa = 0.5522848;
                        const ox = (width / 2) * kappa; // control point offset horizontal
                        const oy = (height / 2) * kappa; // control point offset vertical
                        const xe = centerX + width; // x-end
                        const ye = centerY + height; // y-end
                        const xm = centerX + width / 2; // x-middle
                        const ym = centerY + height / 2; // y-middle

                        creationCtx.beginPath();
                        creationCtx.moveTo(centerX, ym);
                        creationCtx.bezierCurveTo(centerX, ym - oy, xm - ox, centerY, xm, centerY);
                        creationCtx.bezierCurveTo(xm + ox, centerY, xe, ym - oy, xe, ym);
                        creationCtx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                        creationCtx.bezierCurveTo(xm - ox, ye, centerX, ym + oy, centerX, ym);
                        creationCtx.closePath()
                        creationCtx.stroke();

                    }

                } else if(MOVING){
                    console.log('MOVING');

                    const offsetX = originalMousePosition.x - e.clientX;
                    const offsetY = originalMousePosition.y - e.clientY;

                    nodeToMove.style.left = `${nodeToMove.dataset.left - offsetX}px`;
                    nodeToMove.style.top = `${nodeToMove.dataset.top - offsetY}px`;

                }

            }

            function endCreationHandler(e){

                console.log('MOUSEUP');
                
                if(CREATING){

                    creationCtx.clearRect(0, 0, creationCanvas.width, creationCanvas.height);
                    
                    const elementWidth = e.clientX - startCoords.x;
                    const elementHeight = e.clientY - startCoords.y;

                    if(elementWidth === 0 || elementHeight === 0){
                        CREATING = false;
                        startCoords = undefined;
                        return;
                    }

                    const positionX = e.clientX < startCoords.x ? e.clientX : startCoords.x;
                    const positionY = e.clientY < startCoords.y ? e.clientY : startCoords.y;

                    const node = twinNodes.create(positionX, positionY, elementWidth, elementHeight, selectedTool, utilities.uuid());

                    bindCreationHandlersToNode(node);

                    nodesHolder.appendChild(node);
                
                } else if(MOVING){
                    
                    finishMoveOfNodeAndSetPosition();

                }

                CREATING = false;


            }

            const twinUUID = "{{twinData.UUID}}";
            const nodesHolder = document.querySelector('#nodes');
            const toolBox = document.querySelector('#toolBox');
            const colorSelectorHolder = document.querySelector('#colorSelect');
            const colorSelector = colorSelectorHolder.querySelector('input[type="color"]');
            const colorSelectorOutput = colorSelectorHolder.querySelector('p');
            const creationCanvas = document.querySelector('canvas#creationCanvas');
            const creationCtx = creationCanvas.getContext('2d');

            creationCanvas.width = window.innerWidth * window.devicePixelRatio;
            creationCanvas.height = window.innerHeight * window.devicePixelRatio;

            creationCtx.strokeStyle = "#333333";
            creationCtx.lineWidth = 4;

            let CREATING = false;
            let startCoords = undefined;
            let selectedTool = toolBox.querySelector('li[data-selected="true"]').dataset.toolname;
            
            let MOVING = false;
            let originalMousePosition;
            let nodeToMove;

            creationCanvas.addEventListener('mousedown', startCreationHandler, false);
            
            creationCanvas.addEventListener('mousemove', inProgressCreationHandler, false);
            toolBox.addEventListener('mousemove', inProgressCreationHandler, false);
            
            creationCanvas.addEventListener('mouseup', endCreationHandler, false);
            toolBox.addEventListener('mouseup', endCreationHandler, false);

            Array.from(toolBox.querySelectorAll('li')).map(tool => {

                tool.addEventListener('click', function(){

                    Array.from(toolBox.querySelectorAll('li')).forEach(tool => {

                        tool.dataset.selected = "false";

                    }, false);

                    this.dataset.selected = "true";
                    selectedTool = this.dataset.toolname;

                }, false);

            }, false);

            // Reconstruct pre-existing nodes
            const existingNodes = JSON.parse(`{{{ twinData.nodes }}}`);

            existingNodes.forEach(savedNode => {

                // x, y, width, height, type = selectedTool
                const recreatedNode = twinNodes.create(savedNode.left, savedNode.top, savedNode.width, savedNode.height, savedNode.type, savedNode.name, savedNode.topic, savedNode.rules);
                
                bindCreationHandlersToNode(recreatedNode);

                nodesHolder.appendChild(recreatedNode);

            });

            const nodeMutationObsererOptions = {
                childList: true,
                attributes: true,
                subtree: true
            };

            const NodeMutationObserver = new MutationObserver(function(mutations) {
 
                console.log(mutations);

                if(!MOVING){
                    twinNodes.update( Array.from( nodesHolder.querySelectorAll('div.node') ), twinUUID );
                }
 
            });

            NodeMutationObserver.observe(nodesHolder, nodeMutationObsererOptions);       

            colorSelector.addEventListener('change', function(e){

                console.log("change", this.value);
                creationCanvas.style.backgroundColor = this.value;
                colorSelectorOutput.textContent = this.value.toUpperCase();

            }, false);

            window.addEventListener('keydown', (e) => {
                console.log(e);
                // If the backspace key is pressed, and a node is selected, but the none of the input
                // fields in the configuration panel are being edited, delete the selected node.
                if(e.keyCode === 8 && e.ctrlKey === true){
                    const selectedNode = nodesHolder.querySelector('.node[data-selected="true"]');
                    selectedNode.parentNode.removeChild(selectedNode);
                    configurationPanel.hide();
                }
            });

            window.addEventListener('resize', (e) => {
                creationCanvas.width = window.innerWidth * window.devicePixelRatio;
                creationCanvas.height = window.innerHeight * window.devicePixelRatio;
            }, false);

        }());

    </script>

</main>