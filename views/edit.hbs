<main>

	<canvas id="creationCanvas"></canvas>

    <div id="nodes">

        <!-- The output is where our nodes are persisted -->

    </div>

    <div id="configurePanel" data-active="false">
        <h2>Configure Node</h2>
        <div id="closePanelBtn"></div>

        <form>
            <label>Topic</label>
            <input type="text" name="topic" placeholder="MQTT topic to subscribe and react to..." />

            <label>Rules</label>

            <div id="nodeRules">

                <ol id="storedRules">

                    <!--<li class="rule">
                        <div class="ruleDetails">
                            <input type="text" name="rule_name" placeholder="Rule Name"/>
                            <div class="ruleCondition">
                                <strong>IF</strong> <input type="text" class="userInput" name="property" placeholder="property" /> &#61;&#61;&#61; <input type="text" class="userInput" name="value" placeholder="value"/><br/>
                            </div>

                            <div class="ruleAction">
                                <strong>SET COLOR</strong> <input type="color" id="head" name="head" value="#f5f5f5" class="userInput">
                            </div>

                        </div>
                        <div class="deleteRuleButton"></div>
                    </li>-->

                </ol>

                <button id="newRule">Add new rule</button>
            </div>

        </form>

    </div>

    <ul id="toolBox">

        <li data-selected="true" data-toolname="square" id="squareCreationTool"></li>
        <li data-selected="false" data-toolname="ellipse" id="ellipseCreationTool"></li>
        <li data-selected="false" data-toolname="select" id="selectionTool"></li>
        <li data-selected="false" data-toolname="image" id="imageTool"></li>

    </ul>

    <div id="colorSelect">
        <input type="color" id="head" name="head" value="#f5f5f5">
        <p> <strong> #F5F5F5 </strong> </p>
    </div>

    <div id="backgroundImageOverlay" data-active="false" data-imageplaced="false">

        <div id="imageDropInstructions">
            <p>Drag and drop an image onto the browser to set it as the background for the twin</p>
        </div>

        <div id="imagePositionAndSizer">
            <img src="">
        </div>

        <div id="backgroundImageOverlayActions">
            <button data-action="cancel">Cancel</button>
            <button data-action="save">Save</button>
        </div>

    </div>

    <div id="twinDetails">
        <span>Twin name:</span> <h3 id="twinNameSetting" contenteditable="true">{{twinData.name}}</h3>
        <span>Twin Broker: </span> <h3 id="twinBrokerSetting" contenteditable="true">{{twinData.broker}}</h3>
        <a href="/view/{{twinData.UUID}}" target="_blank">View Twin</a>
    </div>

    <script src="/scripts/utilities.js"></script>
    <script src="/scripts/twin_nodes.js"></script>
    <script>

        (function(){

            'use strict';

            const configurationPanel = (function(){

                const configurationPanelElement = document.querySelector('#configurePanel');
                let currentNodeBeingConfigured = undefined;

                const rulesContainer = configurationPanelElement.querySelector('#nodeRules');
                const storedRules = rulesContainer.querySelector('#storedRules');
                const newRulesButton = configurationPanelElement.querySelector('#newRule');

                function createRule(name, conditionProperty = "", conditionValue = "", actionValue = ""){

                    const ruleFragment = document.createDocumentFragment();

                    const newRule = document.createElement('li');
                    const ruleDetailsContainer = document.createElement('div');
                    const ruleConditionContainer = document.createElement('div');
                    const ruleActionContainer = document.createElement('div');
                    const deleteRuleButton = document.createElement('div');
                    const nameInput = document.createElement('input');

                    newRule.classList.add('rule');
                    ruleDetailsContainer.classList.add('ruleDetails');
                    ruleConditionContainer.classList.add('ruleCondition');
                    ruleActionContainer.classList.add('ruleCondition');
                    deleteRuleButton.classList.add('deleteRuleButton');

                    nameInput.setAttribute('type', 'text');
                    nameInput.setAttribute('name', 'rule_name');
                    nameInput.setAttribute('placeholder', 'Rule Name');

                    nameInput.value = name || "";
                    ruleConditionContainer.innerHTML = `<strong>IF</strong> <input type="text" class="userInput" name="property" placeholder="property" value="${conditionProperty}" /> &#61;&#61;&#61; <input type="text" class="userInput" name="value" placeholder="value" value="${conditionValue}"/><br/>`;
                    ruleActionContainer.innerHTML = `<strong>SET COLOR</strong> <input type="color" id="head" name="head" value="${actionValue}" class="userInput">`

                    deleteRuleButton.addEventListener('click', function(){

                        storedRules.removeChild(this.parentNode);

                    }, false);

                    ruleDetailsContainer.appendChild(nameInput);
                    ruleDetailsContainer.appendChild(ruleConditionContainer);
                    ruleDetailsContainer.appendChild(ruleActionContainer);

                    newRule.appendChild(ruleDetailsContainer);
                    newRule.appendChild(deleteRuleButton);

                    ruleFragment.appendChild(newRule);

                    return ruleFragment;

                }

                newRulesButton.addEventListener('click', function(e){
                    e.preventDefault();
                    e.stopImmediatePropagation();

                    const newRule = createRule();

                    storedRules.appendChild(newRule);

                }, false);

                function showConfigurationPanel(node){
                    console.log("ShowPanel");

                    currentNodeBeingConfigured = node;
                    storedRules.innerHTML = "";

                    configurationPanelElement.querySelector('input[name="topic"]').value = currentNodeBeingConfigured.dataset.topic;

                    if(currentNodeBeingConfigured.dataset.rules){

                        const rules = JSON.parse(currentNodeBeingConfigured.dataset.rules);

                        rules.forEach(rule => {

                            const existingRule = createRule(rule.name, rule.property, rule.value, rule.action);
                            storedRules.appendChild(existingRule);

                        });

                    }

                    configurationPanelElement.dataset.active = "true";

                }

                function hideConfigurationPanel(saveChanges = true){

                    console.log('save changes?', saveChanges);

                    if(!currentNodeBeingConfigured){
                        return;
                    }

                    if(true /*saveChanges*/){

                        currentNodeBeingConfigured.dataset.topic = configurationPanelElement.querySelector('input[name="topic"]').value;
                        const rules = Array.from(storedRules.querySelectorAll('.rule')).map(storedRule => {
                            console.log(storedRule);

                            const property = storedRule.querySelector('input[name="property"]').value;
                            const value = storedRule.querySelector('input[name="value"]').value;
                            const action = storedRule.querySelector('input[type="color"]').value;

                            return {
                                name : storedRule.querySelector('input[name="rule_name"]').value,
                                property : property,
                                value : value,
                                action : action
                            };

                        });

                        currentNodeBeingConfigured.dataset.rules = JSON.stringify(rules);

                    }

                    currentNodeBeingConfigured = undefined;
                    configurationPanelElement.dataset.active = "false";

                    Array.from(storedRules.querySelectorAll('.rule')).forEach(storedRule => {
                        storedRule.parentNode.removeChild(storedRule);
                    });

                    Array.from(nodesHolder.querySelectorAll('.node')).forEach(node => {
                        node.dataset.selected = "false";
                    });

                }

                function checkIfConfigurationPanelIsShowing(){
                    return configurationPanelElement.dataset.active === "true";
                }

                configurationPanelElement.querySelector('#closePanelBtn').addEventListener('click', e => {
                    hideConfigurationPanel(false);
                }, false);

                return {
                    show : showConfigurationPanel,
                    hide : hideConfigurationPanel,
                    isVisible : checkIfConfigurationPanelIsShowing
                };

            }());

            // This function needs a better name
            function bindCreationHandlersToNode(node, backgroundImage = false){

                function finishMoveOfNodeAndSetPosition(){

                    MOVING = false;
                    nodeToMove.dataset.top = nodeToMove.style.top.replace('px', '');
                    nodeToMove.dataset.left = nodeToMove.style.left.replace('px', '');

                    originalMousePosition = undefined;
                    nodeToMove = undefined;

                    document.body.dataset.movingnode = "false";

                }

                function handleDownEvent(e){

                    e.preventDefault();
                    e.stopImmediatePropagation();

                    MOVING = true;
                    nodeToMove = e.target;
                    document.body.dataset.movingnode = true;

                    originalMousePosition = {
                        x : e.clientX,
                        y : e.clientY
                    };

                }

                function handleUpEvent(e){

                    e.stopPropagation();
                    e.stopImmediatePropagation();

                    console.log('NODE CLICK');

                    if(originalMousePosition){

                        if(e.clientX === originalMousePosition.x && e.clientY === originalMousePosition.y){
                            MOVING = false;
                        }

                    }

                    if(CREATING){
                        endCreationHandler(e);
                    } else if(!MOVING && e.target.classList.contains('node')){
                        configurationPanel.show(e.target);

                        Array.from(nodesHolder.querySelectorAll('.node')).forEach(node => {
                            node.dataset.selected = "false";
                        });

                        e.target.dataset.selected = "true";

                    } else if(MOVING){
                        finishMoveOfNodeAndSetPosition();
                    }

                }

                node.addEventListener('mousedown', handleDownEvent, false);
                node.addEventListener('mousemove', inProgressCreationHandler, false);
                node.addEventListener('mouseup', handleUpEvent, false);

                node.addEventListener("touchstart", function(e){ e.clientX = e.touches[0].clientX; e.clientY = e.touches[0].clientY; handleDownEvent(e); }, false);
                node.addEventListener("touchmove", function(e){ e.clientX = e.touches[0].clientX; e.clientY = e.touches[0].clientY; inProgressCreationHandler(e); }, false);
                node.addEventListener("touchend", function(e){ e.clientX = e.changedTouches[0].clientX; e.clientY = e.changedTouches[0].clientY; handleUpEvent(e); }, false);

            }

            // This function needs a better name
            function startCreationHandler(e){
                console.log('MOUSEDOWN');

                if(!selectedTool){
                    return;
                }

                if(selectedTool !== "select"){

                    CREATING = true;
                    startCoords = {
                        x : e.clientX,
                        y : e.clientY
                    };

                }

            }

            // This function needs a better name
            function inProgressCreationHandler(e){

                if(CREATING){

                    const selectionWidth = e.clientX - startCoords.x;
                    const selectionHeight = e.clientY - startCoords.y;

                    if(selectedTool === "square"){

                        creationCtx.clearRect(0,0, creationCanvas.width, creationCanvas.height);
                        creationCtx.beginPath();
                        creationCtx.strokeRect(startCoords.x * window.devicePixelRatio, startCoords.y * window.devicePixelRatio, selectionWidth * window.devicePixelRatio, selectionHeight * window.devicePixelRatio);
                        creationCtx.stroke();
                        creationCtx.closePath();

                    } else if(selectedTool === "ellipse"){

                        creationCtx.clearRect(0,0, creationCanvas.width, creationCanvas.height);

                        const adjustedX = e.clientX * window.devicePixelRatio;
                        const adjustedY = e.clientY * window.devicePixelRatio

                        const adjustedStartX = startCoords.x * window.devicePixelRatio;
                        const adjustedStartY = startCoords.y * window.devicePixelRatio;

                        const height = (adjustedY - adjustedStartY) ;
                        const width = (adjustedX - adjustedStartX) ;
                        const centerX = ( ( adjustedX - ( (adjustedX - adjustedStartX) / 2 ) ) ) - width / 2;
                        const centerY = ( ( adjustedY - ( (adjustedY - adjustedStartY) / 2 ) ) ) - height / 2;

                        // Borrowed from https://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
                        const kappa = 0.5522848;
                        const ox = (width / 2) * kappa; // control point offset horizontal
                        const oy = (height / 2) * kappa; // control point offset vertical
                        const xe = centerX + width; // x-end
                        const ye = centerY + height; // y-end
                        const xm = centerX + width / 2; // x-middle
                        const ym = centerY + height / 2; // y-middle

                        creationCtx.beginPath();
                        creationCtx.moveTo(centerX, ym);
                        creationCtx.bezierCurveTo(centerX, ym - oy, xm - ox, centerY, xm, centerY);
                        creationCtx.bezierCurveTo(xm + ox, centerY, xe, ym - oy, xe, ym);
                        creationCtx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                        creationCtx.bezierCurveTo(xm - ox, ye, centerX, ym + oy, centerX, ym);
                        creationCtx.stroke();
                        creationCtx.closePath();

                    }

                } else if(MOVING){
                    console.log('MOVING');

                    const offsetX = originalMousePosition.x - e.clientX;
                    const offsetY = originalMousePosition.y - e.clientY;

                    nodeToMove.style.left = `${nodeToMove.dataset.left - offsetX}px`;
                    nodeToMove.style.top = `${nodeToMove.dataset.top - offsetY}px`;

                }

            }

            // This function needs a better name
            function endCreationHandler(e){

                console.log('MOUSEUP');

                if(CREATING){

                    creationCtx.clearRect(0, 0, creationCanvas.width, creationCanvas.height);

                    const elementWidth = e.clientX - startCoords.x;
                    const elementHeight = e.clientY - startCoords.y;

                    if(elementWidth === 0 || elementHeight === 0){
                        CREATING = false;
                        startCoords = undefined;
                        return;
                    }

                    const positionX = e.clientX < startCoords.x ? e.clientX : startCoords.x;
                    const positionY = e.clientY < startCoords.y ? e.clientY : startCoords.y;

                    const node = twinNodes.create(positionX, positionY, elementWidth, elementHeight, selectedTool, utilities.uuid());

                    bindCreationHandlersToNode(node);

                    nodesHolder.appendChild(node);

                } else if(MOVING){

                    finishMoveOfNodeAndSetPosition();

                }

                CREATING = false;

            }

            function updateTwinSettings(){
                {{!-- debugger; --}}
                const twinName = twinNameSetting.textContent;
                const twinBroker = twinBrokerSetting.textContent;

                fetch(`${window.location.origin}/twins/update/${twinUUID}`, {
                        method : 'POST',
                        headers : {
                            'Content-Type' : 'application/json'
                        },
                        credentials : 'same-origin',
                        body: JSON.stringify( { data : { name : twinName, broker: twinBroker } })
                    })
                    .then(res => {
                        if(res.ok){
                            return res.json();
                        } else {
                            throw res;
                        }
                    })
                    .then(result => {
                        console.log('Updated twin settings:', result);
                    })
                    .catch(err => {
                        console.log('Could not update Twin settings. Err:', err);
                    })

                console.log(twinName, twinBroker);

            }

            function saveBackgroundImage(src, type){
                
                {{!-- debugger; --}}

                fetch(`${window.location.origin}/twins/image/set/${twinUUID}`, {
                        method : "POST",
                        headers : {
                            "Content-Type" : "application/json"
                        },
                        credentials : 'same-origin',
                        body : JSON.stringify( { data : { backgroundImage : src, type : type.replace('image/', '') } } )
                    })
                    .then(res => {
                        if(!res.ok){
                            throw res;
                        } else {
                            return res.json()
                        }
                    })
                    .then(data => {
                        console.log(data);
                    })
                    .catch(err => {

                        console.log(`Error saving Digital Twin updates:`, err);

                    })
                ;

            }

            function setBackgroundImage(src, position){

                console.log(src);

                return new Promise( function(resolve){

                    var existingBackgroundImage = nodesHolder.querySelector('.backgroundImage');

                    if(existingBackgroundImage){
                        existingBackgroundImage.parentNode.removeChild(existingBackgroundImage);
                        const existingOverlayImage = backgroundImageOverlay.querySelector('img');

                        existingOverlayImage.parentNode.removeChild(existingOverlayImage);

                    }

                    const backgroundImage = new Image();

                    backgroundImage.classList.add('backgroundImage');

                    backgroundImage.addEventListener('load', function(){
                        console.log('Image Loaded');

                        if(position){
                            backgroundImage.dataset.left = position.left;
                            backgroundImage.dataset.top = position.top;
                        } else {
                            backgroundImage.dataset.left = (window.innerWidth / 2) - (backgroundImage.width / 2);
                            backgroundImage.dataset.top = (window.innerHeight / 2) - (backgroundImage.height / 2);
                        }

                        backgroundImage.style.left = `${backgroundImage.dataset.left}px`;
                        backgroundImage.style.top = `${backgroundImage.dataset.top}px`;

                        {{!-- const overlayBackgroundImage = backgroundImage.cloneNode(); --}}
                        {{!-- bindCreationHandlersToNode(overlayBackgroundImage, true); --}}
                        {{!-- backgroundImageOverlay.appendChild(overlayBackgroundImage); --}}

                        nodesHolder.insertBefore(backgroundImage, document.querySelector('.node'));

                        twinBackgroundImage = backgroundImage;
                        resolve();
                    }, false);

                    backgroundImage.src = src;
                
                } );

            }

            function setOverlayImage(src, position){
                
                const existingOverlayImage = backgroundImageOverlay.querySelector('img');

                if(existingOverlayImage){
                    existingOverlayImage.parentNode.removeChild(existingOverlayImage);
                }

                const overlayImage = new Image();
                overlayImage.classList.add('overlayImage');
                overlayImage.addEventListener('load', function(){
                    
                    if(position){
                        overlayImage.dataset.left = position.left;
                        overlayImage.dataset.top = position.top;
                    } else {
                        overlayImage.dataset.left = (window.innerWidth / 2) - (overlayImage.width / 2);
                        overlayImage.dataset.top = (window.innerHeight / 2) - (overlayImage.height / 2);
                    }

                    
                    overlayImage.style.width = overlayImage.width + "px";
                    overlayImage.style.height = overlayImage.height + "px";
                    overlayImage.style.left = overlayImage.dataset.left + "px";
                    overlayImage.style.top = overlayImage.dataset.top + "px";

                    bindCreationHandlersToNode(overlayImage, true);

                    backgroundImageOverlay.appendChild(overlayImage);

                }, false);

                overlayImage.src = src;

            }

            const twinUUID = "{{twinData.UUID}}";
            const nodesHolder = document.querySelector('#nodes');
            const toolBox = document.querySelector('#toolBox');
            const colorSelectorHolder = document.querySelector('#colorSelect');
            const colorSelector = colorSelectorHolder.querySelector('input[type="color"]');
            const colorSelectorOutput = colorSelectorHolder.querySelector('p');
            const creationCanvas = document.querySelector('canvas#creationCanvas');
            const creationCtx = creationCanvas.getContext('2d');
            const twinNameSetting = document.querySelector('#twinNameSetting');
            const twinBrokerSetting = document.querySelector('#twinBrokerSetting');
            const twinBackgroundImageSrc = {{#if twinData.backgroundImage}}"{{twinData.backgroundImage.url}}"{{else}}undefined{{/if}};
            let twinBackgroundImage;
            const backgroundImageOverlay = document.querySelector('#backgroundImageOverlay');
            const backgroundImageSaveBtn = backgroundImageOverlay.querySelector('button[data-action="save"]');
            const backgroundImageCancelBtn = backgroundImageOverlay.querySelector('button[data-action="cancel"]');

            creationCanvas.width = window.innerWidth * window.devicePixelRatio;
            creationCanvas.height = window.innerHeight * window.devicePixelRatio;

            creationCtx.strokeStyle = "#333333";
            creationCtx.lineWidth = 4;

            let CREATING = false;
            let startCoords = undefined;
            let selectedTool = toolBox.querySelector('li[data-selected="true"]').dataset.toolname;

            let MOVING = false;
            let originalMousePosition;
            let nodeToMove;

            const validImageFileTypes = ['image/jpeg', 'image/png'];

            creationCanvas.addEventListener('mousedown', startCreationHandler, false);
            creationCanvas.addEventListener("touchstart", function(e){ e.clientX = e.touches[0].clientX; e.clientY = e.touches[0].clientY; startCreationHandler(e); }, false);

            creationCanvas.addEventListener('mousemove', inProgressCreationHandler, false);
            creationCanvas.addEventListener("touchmove", function(e){ e.clientX = e.touches[0].clientX; e.clientY = e.touches[0].clientY; inProgressCreationHandler(e); }, false);
            backgroundImageOverlay.addEventListener('mousemove', inProgressCreationHandler, false);
            backgroundImageOverlay.addEventListener("touchmove", function(e){ e.clientX = e.touches[0].clientX; e.clientY = e.touches[0].clientY; inProgressCreationHandler(e); }, false);
            toolBox.addEventListener('mousemove', inProgressCreationHandler, false);

            creationCanvas.addEventListener('mouseup', endCreationHandler, false);
            creationCanvas.addEventListener("touchend", function(e){ e.clientX = e.changedTouches[0].clientX; e.clientY = e.changedTouches[0].clientY; endCreationHandler(e); }, false);
            backgroundImageOverlay.addEventListener('mouseup', endCreationHandler, false);
            backgroundImageOverlay.addEventListener("touchend", function(e){ e.clientX = e.changedTouches[0].clientX; e.clientY = e.changedTouches[0].clientY; endCreationHandler(e); }, false);
            toolBox.addEventListener('mouseup', endCreationHandler, false);

            function handleDragEnter(e){
                e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
                console.log('dragenter event triggered');
            }

            function handleDragLeave(e){
                e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
                console.log('dragleave event triggered');
            }

            function handleDragOver(e){
                e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
                console.log('dragover event triggered');
            }

            function handleDrop(e){
                e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
                console.log('drop event triggered', e);
                let dt = e.dataTransfer
                let file = dt.files[0];

                console.log(dt, file);

                if(validImageFileTypes.indexOf(file.type) > -1){
                    console.log('Valid image file');

                    const reader = new FileReader();
                    reader.readAsDataURL(file)
                    //reader.onloadend = function() {}
                    reader.addEventListener('loadend', function(){
                        console.log(reader.result);

                        backgroundImageOverlay.dataset.imageplaced = "true";
                        {{!-- setBackgroundImage(reader.result); --}}
                        //saveBackgroundImage(reader.result, file.type);
                        setOverlayImage(reader.result);

                    }, false);
                }

            }

            backgroundImageOverlay.addEventListener('dragenter', handleDragEnter, false);
            backgroundImageOverlay.addEventListener('dragleave', handleDragLeave, false);
            backgroundImageOverlay.addEventListener('dragover', handleDragOver, false);
            backgroundImageOverlay.addEventListener('drop', handleDrop, false);

            Array.from(toolBox.querySelectorAll('li')).map(tool => {

                tool.addEventListener('click', function(){

                    Array.from(toolBox.querySelectorAll('li')).forEach(tool => {

                        tool.dataset.selected = "false";

                    }, false);

                    this.dataset.selected = "true";
                    selectedTool = this.dataset.toolname;

                    if(selectedTool === 'image'){
                        
                        if(twinBackgroundImage){
                            setOverlayImage(twinBackgroundImage.src, {left: twinBackgroundImage.dataset.left, top: twinBackgroundImage.dataset.top})
                        }

                        backgroundImageOverlay.dataset.active = "true";
                        configurationPanel.hide();
                    } else {
                        backgroundImageOverlay.dataset.active = "false";
                    }

                }, false);

            }, false);

            // Reconstruct pre-existing nodes
            const existingNodes = JSON.parse(`{{{ twinData.nodes }}}`);

            existingNodes.forEach(savedNode => {

                // x, y, width, height, type = selectedTool
                const recreatedNode = twinNodes.create(savedNode.left, savedNode.top, savedNode.width, savedNode.height, savedNode.type, savedNode.name, savedNode.topic, savedNode.rules);

                bindCreationHandlersToNode(recreatedNode);

                nodesHolder.appendChild(recreatedNode);

            });

            const nodeMutationObsererOptions = {
                childList: true,
                attributes: true,
                subtree: true
            };

            const NodeMutationObserver = new MutationObserver(function(mutations) {

                console.log(mutations);
                const nodeAddedWasImage = mutations[0].addedNodes[0]?.classList.contains('backgroundImage');
                console.log('HERE:', nodeAddedWasImage);

                if(!MOVING){
                    
                    if(!nodeAddedWasImage && nodeAddedWasImage !== undefined){
                        twinNodes.update( Array.from( nodesHolder.querySelectorAll('div.node') ), twinUUID );
                    }

                }

            });

            NodeMutationObserver.observe(nodesHolder, nodeMutationObsererOptions);

            colorSelector.addEventListener('change', function(e){

                console.log("change", this.value);
                creationCanvas.style.backgroundColor = this.value;
                colorSelectorOutput.textContent = this.value.toUpperCase();

            }, false);

            backgroundImageSaveBtn.addEventListener('click', function(){

                console.log("SAVE IMAGE");
                const overlayImage = backgroundImageOverlay.querySelector('img');
                const copyCanvas = document.createElement('canvas');
                copyCanvas.width = overlayImage.width;
                copyCanvas.height = overlayImage.height;

                const copyCtx = copyCanvas.getContext('2d');
                copyCtx.drawImage(overlayImage, 0, 0);
                
                console.log(copyCanvas.toDataURL());
                
                const base64Image = copyCanvas.toDataURL();
                setBackgroundImage(base64Image, { top : overlayImage.dataset.top, left : overlayImage.dataset.left })
                    .then(function(){

                        saveBackgroundImage(base64Image, base64Image.replace('data:image/', '').split(';')[0]);

                        backgroundImageOverlay.dataset.active = "false";
                        toolBox.querySelector('li[data-selected="true"]').dataset.selected = "false";
                        selectedTool = undefined;

                    })
                ;



            }, false);

            backgroundImageCancelBtn.addEventListener('click', function(){

                console.log("CANCEL SAVE IMAGE");
                backgroundImageOverlay.dataset.active = "false";
                toolBox.querySelector('li[data-selected="true"]').dataset.selected = "false";
                selectedTool = undefined;

            }, false);

            if(twinBackgroundImageSrc){
                console.log("Background image exists!");
                setBackgroundImage(`/twins/image/get/${twinBackgroundImageSrc}`);
            }

            twinNameSetting.addEventListener('keydown', function(e){ if( e.keyCode === 13 ){ e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation(); this.blur(); } });
            twinBrokerSetting.addEventListener('keydown', function(e){ if( e.keyCode === 13 ){ e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation(); this.blur(); } });

            twinNameSetting.addEventListener('blur', updateTwinSettings, false);
            twinBrokerSetting.addEventListener('blur', updateTwinSettings, false);

            window.addEventListener('keydown', (e) => {
                console.log(e);
                // If the backspace key is pressed, and a node is selected, but the none of the input
                // fields in the configuration panel are being edited, delete the selected node.

                const selectedNode = nodesHolder.querySelector('.node[data-selected="true"]');

                if(e.keyCode === 8 && e.ctrlKey === true && selectedNode !== null){
                    selectedNode.parentNode.removeChild(selectedNode);
                    configurationPanel.hide();
                }

            });

            window.addEventListener('resize', (e) => {
                creationCanvas.width = window.innerWidth * window.devicePixelRatio;
                creationCanvas.height = window.innerHeight * window.devicePixelRatio;
            }, false);

        }());

    </script>

</main>